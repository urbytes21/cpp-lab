#include <iostream>
using namespace std;

// *1. Members initializer list constructor
namespace InitializerList {
class CConstructors {
 private:
  int m_x, m_y, m_z;

 public:
  CConstructors(int x, int y) : m_x(x), m_y(y) {
    cout << "Called CConstructors(int x, int y) : m_x(x), m_y(y) \n";
    // m_z{0}; // error, it already initialized, so only can do assigment
    // m_z(0); // error, it already initialized, so only can do assigment
    m_z = 0;
  }

  // using brace init
  CConstructors(int x, int y, int z) : m_x{x}, m_y{y}, m_z{z} {
    cout << "Called CConstructors(int x, int y, int z) : m_x{x}, m_y{y}, "
            "m_z{z} \n";
  }

  // default arguments : must always be the RIGHTMOST parameters
  explicit CConstructors(int x = 1) {
    cout << "Called CConstructors(int x = 1) \n";
    m_x = x;
    m_y = 0;
    m_z = 0;
  }

  // CConstructors() = default; error:
  // ‘InitializerList::CConstructors::CConstructors(int)’ cannot be overloaded
  // with ‘InitializerList::CConstructors::CConstructors(int x = 1)’

  void print() const {
    cout << "m_x = " << m_x << ", m_y = " << m_y << ", m_z = " << m_z << "\n";
  }
};

void constructers() {
  cout << "\n--- InitializerList Constructer Examples ---\n";
  CConstructors obj;
  CConstructors obj1 = CConstructors(1, 2);
  obj1.print();

  CConstructors obj2 = CConstructors(3, 4, 5);
  obj2.print();
}
}  // namespace InitializerList

// *2. Default constructor:
// It is a constructor that accepts no arguments.
// Generated if no constructors are declared
// Initializes members: basic types uninitialized, class types call their
// default constructor
namespace Default {
class UConstructors {
 public:
  // User-defined default constructor without argument
  UConstructors() { cout << "Called UConstructors() \n"; }
};

class IConstructors {
 public:
  // Implicit default constructor is generated by the compiler when the class
  // has no user-declared constructors
};

class EConstructors {
 public:
  // we already create the constructor ourselves
  //  EConstructors(int a)
  explicit EConstructors(float a)  // explicit ->         [[maybe_unused]]
                                   // EConstructors obj2 = 1; [ERROR]

  {
    cout << "Called explicit EConstructors(int a) \n";
  }

  // Explicit default constructor : also want the compiler to generate the
  // default constructor.
  EConstructors() = default;
};

void constructers() {
  cout << "\n--- Default Constructer Examples ---\n";
  [[maybe_unused]] UConstructors obj1;
  // [[maybe_unused]] UConstructors obj2(); // wrong, this is function declare
  // FYI:
  // void outer()
  // {
  //     void helper();
  //     helper(); // defined later in the same file
  // }

  [[maybe_unused]] UConstructors obj3{};

  [[maybe_unused]] IConstructors obj4;
  [[maybe_unused]] IConstructors obj6{};

  [[maybe_unused]] EConstructors obj7;
  [[maybe_unused]] EConstructors obj9{};

  [[maybe_unused]] EConstructors obj10(1.2);
  [[maybe_unused]] EConstructors obj11{2};
}
}  // namespace Default

// *3. Delegate constructor: allow to delegate initialization to another
// constructor Never generated automatically
namespace Delegate {
class CConstructor {
 private:
  int m_x;
  int m_y;

 public:
  CConstructor(int x, int y) : m_x{x}, m_y{y} {
    cout << "Called  CConstructor(int x, int y) : m_x{x}, m_y{y} \n";
  }

  explicit CConstructor(int x) : CConstructor{x, 1} {
    cout << "Called   CConstructor(int x):CConstructor(x,0) \n";
  }

  CConstructor() : CConstructor(0) {
    cout << "Called    CConstructor() : CConstructor(0) \n";
  }

  void print() const { cout << "m_x = " << m_x << ", m_y = " << m_y << "\n"; }
};

void constructors() {
  cout << "\n--- Delegate Constructer Examples ---\n";
  CConstructor obj1 = CConstructor();
  obj1.print();
}
}  // namespace Delegate

// *4.  Copy constructor:  initialize an copy object with an existing object
// Generated if no copy/move constructor or `destructor` is declared
// Performs memberwise (shallow) copy
//  * Copy constructor
// Object obj1 = obj2
// Object obj1(obj2)
// Object obj1{obj2}
//  * Copy assigment
// obj1 = obj1
namespace Copy {
class
    ICConstructor  // C++ will create a public implicit copy constructor for us
                   // if we do not provide a one.
{
 private:
  int m_x;
  int m_y;

 public:
  ICConstructor(int x, int y) : m_x{x}, m_y{y} {
    cout << "Called  ICConstructor(int x, int y) : m_x{x}, m_y{y} \n";
  }

  void print() const { cout << "m_x = " << m_x << ", m_y = " << m_y << "\n"; }
};

class ECConstructor  // explicitly define our own copy constructor
{
 private:
  int m_x;
  int m_y;

 public:
  ECConstructor(int x, int y) : m_x{x}, m_y{y} {
    cout << "Called  ICConstructor(int x, int y) : m_x{x}, m_y{y} \n";
  }

  // Implicit Copy constructor if there is no desconstrutor
  // using `default` keyword
  // ECConstructor(const ECConstructor &ref) = default;

  // Explicit Copy constructor (a=ECConstructor(b))
  ECConstructor(const ECConstructor& ref) : m_x{ref.m_x}, m_y{ref.m_x} {
    cout << "Called  ECConstructor(const ECConstructor& ref) : m_x{ref.m_x}, "
            "m_y{ref.m_x} \n";
  }

  // Copy assigment (a=b)
  ECConstructor& operator=(const ECConstructor& other) {
    if (this != &other) {
      this->m_x = other.m_x;
      this->m_y = other.m_y;
    }
    return *this;
  }

  void print() const { cout << "m_x = " << m_x << ", m_y = " << m_y << "\n"; }
};

class DECConstructor  // Delete the copy constructor so no copies can be made
{
 private:
  int m_x;
  int m_y;

 public:
  DECConstructor(int x, int y) : m_x{x}, m_y{y} {
    cout << "Called  DECConstructor(int x, int y) : m_x{x}, m_y{y} \n";
  }

  // using `delete` keyword
  DECConstructor(const DECConstructor& fraction) = delete;

  void print() const { cout << "m_x = " << m_x << ", m_y = " << m_y << "\n"; }
};

void constructors() {
  cout << "\n--- Copy Constructer Examples ---\n";
  ICConstructor obj1 = ICConstructor(1, 2);
  ICConstructor obj2{obj1};
  obj1.print();
  obj2.print();

  ECConstructor obj3 = ECConstructor(3, 4);
  ECConstructor obj4{obj3};
  obj3.print();
  obj4.print();

  DECConstructor obj5 = DECConstructor(5, 6);
  // DECConstructor obj6{obj5}; error
  obj5.print();
}
}  // namespace Copy

// *4. Move Constructor:
// Move constructor and move assignment transfer resource ownership
// from one object to another. This is usually cheaper than copying.
// A move constructor is implicitly generated only if no user-declared
// copy constructor, move constructor, or destructor exists.
namespace Move {
class Model  // C++ will create a public implicit copy constructor for us if we
             // do not provide a one.
{
 private:
  int m_x;
  int m_y;

 public:
  Model(int x, int y) : m_x{x}, m_y{y} { cout << "Call constructor \n"; }

  ~Model() { cout << "Call destructor \n"; }

  Model(const Model& other) : Model(other.m_x, other.m_y) {
    cout << "Call copy constructor \n";
  }

  Model& operator=(const Model& other) {
    cout << "Call copy assigment \n";
    if (this != &other) {
      this->m_x = other.m_x;
      this->m_y = other.m_y;
    }
    return *this;
  }

  Model(Model&& source) noexcept : m_x(source.m_x), m_y(source.m_y) {
    cout << "Call move constructor\n";

    // reset source
    source.m_x = 0;
    source.m_y = 0;
  }

  Model& operator=(Model&& source) noexcept {
    cout << "Call move assigment \n";
    if (this != &source) {
      this->m_x = source.m_x;
      this->m_y = source.m_y;

      // reset source
      source.m_x = 0;
      source.m_y = 0;
    }

    return *this;
  }

  void print() const { cout << "m_x = " << m_x << ", m_y = " << m_y << "\n"; }
};

void constructers() {
  cout << "\n--- Move Constructor Examples ---\n";
  Model a(10, 20);

  cout << "\nCase 1: Model b = std::move(a);\n";
  Model b = std::move(a);  // move constructor

  cout << "\nCase 2: Model c(5,6); c = std::move(b);\n";
  Model c(5, 6);
  c = std::move(b);  // move assignment
  cout << "\n";
}
}  // namespace Move

struct CConstructorsAutoRuner {
  CConstructorsAutoRuner() {
    InitializerList::constructers();
    Default::constructers();
    Delegate::constructors();
    Copy::constructors();
    Move::constructers();
  }
};

static CConstructorsAutoRuner instance;
